

@----------------------------------------------------------------------@
@                   DATA TRANSFORMATION PROCEDURE                      @
@                   -----------------------------                      @
@                this procedure transforms the data set:               @
@                first: data standarization                            @
@                second: cross-sectional de-mean                       @
@                third: organization of data for the LIML estimation   @
@----------------------------------------------------------------------@

proc(2)=transf1(rawdata);
local xdata, xmean, xstd, xdatas,
      dmtx, csddata, j, varname, tmp, tmp0, R,
    limldata, limldata0, limldata1, limldata2, limldata3, limldata4, limldata5, limldata6, limldata7,
    limldata8, limldata9, limldata10, limldata11, limldata12, limldata13, limldata14, limldata15, limldata16; @ Here, we have to insert limldata0:t  @ 

@ we first standarize the Xs regressors to facilitate convergence 
    I also added Y  @
xdata = rawdata[.,1:cols(rawdata)];
xmean = ((meanc(xdata))').*.(ones(rows(xdata),1));
xstd = ((stdc(xdata))').*.(ones(rows(xdata),1));
xdatas = ( xdata - xmean ) ./ xstd;
rawdata[.,1:cols(rawdata)] = xdatas;

@ dmtx will be the matrix for cross-sectional de-meaning          @
dmtx=eye(n*t)-ones(n,n).*.((1/n)*eye(t));

@ csddata will be cross-sectional de-meaned data (time dummies)   @
csddata=dmtx*rawdata;


@ now I organize the data for the Limited Information Maximum Likelihood parametrization @
    @ following loop creates local variable limldata0 @
varname = "limldata";
    tmp0 = zeros(n,1);
for ii(1, n, 1);
    tmp0[ii,.]=csddata[(ii-1)*t+1,2];
    call varputl(tmp0, varname$+ftos(0, "%*.*lf", 0, 0) ); @ call is used to discard the GAUSS returns (ones)  @
endfor;
 @This loop creates local variables limldata1:limldatat and unites them in limldata@
limldata = zeros(n, ktoty*t);
R = zeros(n, ktoty);
tmp = zeros(n, ktoty);

for i(1, t, 1);  
    for j(1, n, 1);
       tmp[j,.]=csddata[(j-1)*t+i,1 3:cols(csddata)];    
    endfor;
    call varputl(tmp, varname$+ftos(i, "%*.*lf", 0, 0) );
    R = vargetl(varname$+ftos(i, "%*.*lf", 0, 0) );
        for jj (1, ktoty, 1);
            limldata[.,jj+(i-1)*ktoty] = R[.,jj];
        endfor;
endfor;

retp (csddata,limldata0~limldata);
endp;



@-----------------------------------------------------------------@
@                  MODEL SELECTION PROCEDURE                      @
@                  ---------------------------                    @
@               this procedure takes as input a number            @
@               and it converts the number to its binary          @
@               representation in base ktotx                      @
@               in order to be a "model".                         @
@-----------------------------------------------------------------@

proc(1) = msel(turu);
local x,z,v,i;
v=zeros(ktotx,1);
x=2^(ktotx-1);
z=turu;
for i(1,ktotx,1);
    if z>x;
        v[i]=1;
        z=z-x;
    else;
        v[i]=0;
    endif;
x=x/2;
endfor;
retp(v);
endp;


@-----------------------------------------------------------------@
@                        HESSIAN PROCEDURE                        @
@                        -----------------                        @
@               this procedure takes as input a number            @
@               computes the kxk (2-sided) hessian matrix         @
@-----------------------------------------------------------------@

proc(1) = myhess(&f,x0);
local k, hessi, h, jc, jr, x1, x2, x3, x4;
local f:proc;
@ The symbol f in the statement above will be treated as a procedure
    whenever it is accessed in the current procedure. 
    What is actually passed in is a pointer to a lik procedure in our case. @
k=rows(x0); @ x0 is theta, our model-specific optimized parameters @
hessi=zeros(k,k);
h=1e-3;

for jc(1,k,1);
    for jr(1,jc,1);
        x1=x0;
        x2=x0;
        x3=x0;
        x4=x0;
        x1[jr]=x0[jr]+h;
        x1[jc]=x1[jc]+h;
        x2[jr]=x0[jr]+h;    
        x2[jc]=x2[jc]-h;
        x3[jr]=x0[jr]-h;
        x3[jc]=x3[jc]+h;
        x4[jr]=x0[jr]-h;
        x4[jc]=x4[jc]-h;
        hessi[jr,jc]=(f(x1)-f(x2)-f(x3)+f(x4))/(4*h^2); @ the second symmetric derivative has different formula @
        hessi[jc,jr]=hessi[jr,jc];
    endfor;
endfor;

retp(hessi);
endp;
